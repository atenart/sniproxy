// Copyright (C) 2019 Antoine Tenart <antoine.tenart@ack.tf>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

package config

import (
	"log"
	"os"
	"regexp"
	"strings"
)

// Config holds the entire current configuration.
type Config struct {
	Routes  []*Route
}

// Route represents a route between matched domains and a backend.
type Route struct {
	Domains []*regexp.Regexp
	Backend string
}

// Reads a configuration file and tranforms it into a Config struct.
func (c *Config) ReadFile(file string) error {
	f, err := os.Open(file)
	if err != nil {
		return err
	}
	defer f.Close()

	l := newLexer(f)
	c.parse(newBlock(&l))

	return nil
}

// Parses the blocks generated by the parser and generate the configuration.
func (c *Config) parse(root *Block) {
	for _, block := range(root.blocks) {
		route := &Route{}
		c.Routes = append(c.Routes, route)

		domains := strings.Split(block.label, ",")
		for _, domain := range(domains) {
			rgp, err := domain2Regex(domain)
			if err != nil {
				log.Fatal("Invalid domain: " + domain)
			}

			route.Domains = append(route.Domains, rgp)
		}

		for _, dir := range(block.directives) {
			switch dir.directive {
			case "backend":
				if len(dir.args) == 0 {
					log.Fatal("Invalid backend directive.")
				}
				route.Backend = dir.args[0]
				break
			default:
				continue
			}
		}
	}
}

// Converts a domain to a regexp.Regexp.
func domain2Regex(domain string) (*regexp.Regexp, error) {
	// Translate the domains into a regexp valid string.
	regex := ""
	for _, r := range domain {
		switch r {
		case '*':
			regex += `.*`
			break
		case '.':
			regex += `\.`
			break
		default:
			regex += string(r)
		}
	}

	return regexp.Compile(regex)
}
