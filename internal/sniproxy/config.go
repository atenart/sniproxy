// Copyright (C) 2019-2022 Antoine Tenart <antoine.tenart@ack.tf>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

package sniproxy

import (
	"fmt"
	"net"
	"os"
	"regexp"
	"strings"

	"github.com/atenart/sniproxy/internal/lexer"
	"github.com/atenart/sniproxy/internal/log"
)

// Config holds the entire current configuration.
type Config struct {
	Routes  []*Route
}

// Route represents a route between matched domains and a backend.
type Route struct {
	Domains   []*regexp.Regexp
	// Default backend.
	Backend   *Backend
	// Backend for ACME.
	ACME      *Backend
	// Bypass ACLs for ACME.
	AllowACME bool
	// Deny and Allow contain lists of IP ranges and/or addresses to
	// whitelist or blacklist for a given route. If Allow is used, all
	// addresses are then blocked by default.
	// The more specific subnet takes precedence, and Deny wins over Allow
	// in case none is more specific.
	Deny      []*net.IPNet
	Allow     []*net.IPNet
}

// Backend represents a backend and its options.
type Backend struct {
	Address   string
	// HAProxy PROXY protocol support (None, v1, v2).
	SendProxy uint
}

// SendProxy possible values.
const (
	ProxyNone = iota
	ProxyV1
	ProxyV2
)

// Matches an SNI to a backend.
func (c *Config)MatchBackend(sni string) *Route {
	// Loop over each route described in the configuration.
	for _, route := range c.Routes {
		// Loop over each domain of a given route.
		for _, domain := range route.Domains {
			if domain.MatchString(sni) {
				return route
			}
		}
	}

	log.Printf(log.INFO, "No route matching the requested domain (%s)", sni)
	return nil
}

// Reads a configuration file and transforms it into a Config struct.
func (c *Config) ReadFile(file string) error {
	f, err := os.Open(file)
	if err != nil {
		return err
	}
	defer f.Close()

	l := lexer.NewLexer(f)
	if err := c.parse(lexer.ParseDirective(&l)); err != nil {
		log.Print(log.ERR, err)
		return err
	}

	return nil
}

// Parses the directives generated by the parser and generate the configuration.
func (c *Config) parse(root *lexer.Directive) error {
	for _, directive := range(root.Directives) {
		route := &Route{}
		c.Routes = append(c.Routes, route)

		domains := strings.Split(directive.Name, ",")
		for _, domain := range(domains) {
			rgp, err := domain2Regex(domain)
			if err != nil {
				return fmt.Errorf("Invalid domain: " + domain)
			}

			route.Domains = append(route.Domains, rgp)
		}

		for _, dir := range(directive.Directives) {
			switch dir.Name {
			case "backend":
				if len(dir.Args) != 1 {
					return fmt.Errorf("Invalid backend directive")
				}
				var err error
				if route.Backend, err = parseBackend(dir); err != nil {
					return err
				}
				break
			case "acme":
				if len(dir.Args) != 1 {
					return fmt.Errorf("Invalid acme directive")
				}
				var err error
				if route.ACME, err = parseBackend(dir); err != nil {
					return err
				}
				break
			case "deny":
				if len(dir.Args) != 1 {
					return fmt.Errorf("Invalid deny directive")
				}
				for _, subnet := range(strings.Split(dir.Args[0], ",")) {
					r, err := parseRange(subnet)
					if err != nil {
						return err
					}
					route.Deny = append(route.Deny, r)
				}
				break
			case "allow":
				if len(dir.Args) != 1 {
					return fmt.Errorf("Invalid allow directive")
				}
				for _, subnet := range(strings.Split(dir.Args[0], ",")) {
					if subnet == "acme" {
						route.AllowACME = true
						continue
					}
					r, err := parseRange(subnet)
					if err != nil {
						return err
					}
					route.Allow = append(route.Allow, r)
				}
				break
			default:
				continue
			}
		}

		if len(route.Allow) > 0 {
			// When using the allow directive, we should block all
			// other IPs. Set Deny to match all IPs.
			_, all4, _ := net.ParseCIDR("0.0.0.0/0")
			_, all6, _ := net.ParseCIDR("::/0")
			route.Deny = append(route.Deny, all4)
			route.Deny = append(route.Deny, all6)
		}
	}

	return nil
}

func parseBackend(directive *lexer.Directive) (*Backend, error) {
	backend := &Backend{
		Address: directive.Args[0],
		SendProxy: ProxyNone,
	}

	for _, d := range(directive.Directives) {
		switch d.Name {
		// HAProxy PROXY protocol (v1)
		case "send-proxy":
			if len(d.Args) > 0 {
				return nil, fmt.Errorf("Invalid send-proxy directive")
			}
			backend.SendProxy = ProxyV1
			break
		// HAProxy PROXY protocol (v2)
		case "send-proxy-v2":
			if len(d.Args) > 0 {
				return nil, fmt.Errorf("Invalid send-proxy directive")
			}
			backend.SendProxy = ProxyV2
			break
		}
	}

	return backend, nil
}

// Converts a domain to a regexp.Regexp.
func domain2Regex(domain string) (*regexp.Regexp, error) {
	// Translate the domains into a regexp valid string.
	regex := "^"
	for _, r := range domain {
		switch r {
		case '*':
			regex += `.*`
			break
		case '.':
			regex += `\.`
			break
		default:
			regex += string(r)
		}
	}
	regex += "$"

	return regexp.Compile(regex)
}

// Parse a subnet string.
func parseRange(subnet string) (*net.IPNet, error) {
	_, ipnet, err := net.ParseCIDR(subnet)
	if err == nil {
		return ipnet, nil
	}

	ip := net.ParseIP(subnet)
	if ip == nil {
		return nil, fmt.Errorf("Could not parse subnet " + subnet)
	}

	// IP is an IPv4 address, its CIDR should be /32.
	if v4 := ip.To4(); v4 != nil {
		return &net.IPNet{ IP: ip, Mask: net.CIDRMask(32, 32) }, nil
	}

	// IP is an IPv6 address, its CIDR should be /128.
	return &net.IPNet{ IP: ip, Mask: net.CIDRMask(128, 128) }, nil
}
